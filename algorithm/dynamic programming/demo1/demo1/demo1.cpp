#include <stdio.h>
#include <Windows.h>

/*
题目：有一个小偷，计划偷窃沿街的房屋，但是不能偷两个相邻的房屋，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个数组，数组里的每个数值代表每个房屋里的财物价值，计算不触发警报的情况下能够偷窃到的最高金额。

例：
输入: [1, 2, 4, 1]
输出: 5
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 4)

输入: [3, 7, 9, 3, 2]
输出: 14
解释: 偷窃 1 号房屋 (金额 = 3), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 2)。
偷窃到的最高金额 = 3 + 9 + 2 = 14
*/

/*
动态规划程序设计往往是针对一种最优化问题
重叠子问题，最优子结构，状态转移方程

状态转移方程:
	如果选择了当前的，则它的前一个就不能选
	dp[i] = max(v[i] + dp[i - 2], dp[i - 1]);

*/

int max_dp(int a, int b)
{
	if (a < b)
		return b;
	else
		return a;
}

int main()
{
	int n;
	int a[100] = { 0 };
	int dp[100] = { 0 };
	scanf("%d", &n);
	for (int i = 0; i < n; ++i)
	{
		scanf("%d", &a[i]);
	}
	for (int i = 0; i < n; ++i)
	{
		if (0 == i)
		{
			dp[i] = a[i];
		}
		else if (1 == i)
		{
			dp[i] = max_dp(a[0], a[1]);
		}
		else
		{
			dp[i] = max_dp(a[i] + dp[i - 2], dp[i - 1]);  //状态转移方程
		}
	}
	printf("%d\n",dp[n-1]);
	system("pause");
	return 0;
}